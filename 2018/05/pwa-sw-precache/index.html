<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"> <!-- pwa meta begin --><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#000"><meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="msapplication-tap-highlight" content="no"> <!-- IOS不会读取manifest中的icon，用此配置进行适配 --><link rel="apple-touch-icon" href="assets/icons/icon-96x96.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/icon-180x180.png"><link rel="apple-touch-icon" sizes="167x167" href="/assets/icons/icon-167x167.png"> <!-- ios修复splash黑屏 --><link href="/assets/icons/apple_splash_1125.png" sizes="1125x2436" rel="apple-touch-startup-image" /><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"> <!-- pwa meta end --><title>使用 sw-precache 构建 Progressive Web App</title><meta name="description" content=""><meta name="keywords" content="pwa,sw-precache,sw,service-worker"><link rel="icon" href="/assets/favicon.ico"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/2018/05/pwa-sw-precache/"><link rel="alternate" type="application/atom+xml" title="Vinny Wong's Blog" href="/feed.xml" /></head><body> <!-- 全局页面loading --><div class="loading"><div class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div></div><!-- search --><div class="searchform"> <a href="javascript:void(0);" class="searchicon"></a> <input type="text" id="keyword"/> <a href="javascript:void(0);" class="clear"></a><ul class="suggest"></ul></div><script src="/assets/jquery-1.9.1.min.js"></script> <!-- 图片懒加载 --> <!-- <script src="//cdn.jsdelivr.net/npm/lozad"></script> --> <script src="/assets/main.js"></script><nav class="header-nav"> <a class="page-link" href="/">HOME</a> / <a class="page-link" href="/categories/">CATEGORY</a> / <a class="page-link" href="/feed.xml">FEED</a> / <a class="page-link" href="/about/">ABOUT</a></nav><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article> <!-- 目录导航，在nav,js中进行渲染 --><div class="w-catalog"></div><div class="w-catalog-btn">目录</div><div class="center"><h1>使用 sw-precache 构建 Progressive Web App</h1><time>2018-05-11</time></div><div class="divider"></div><ul id="markdown-toc"><li><a href="#1-sw-precache-介绍" id="markdown-toc-1-sw-precache-介绍">1. Sw-Precache 介绍</a></li><li><a href="#2-sw-precache-安装" id="markdown-toc-2-sw-precache-安装">2. Sw-Precache 安装</a></li><li><a href="#3-编写gulpfilejs文件" id="markdown-toc-3-编写gulpfilejs文件">3. 编写gulpfile.js文件</a></li><li><a href="#4-生成service-worker文件" id="markdown-toc-4-生成service-worker文件">4. 生成service-worker文件</a></li><li><a href="#5-首页文件注册serviceworker" id="markdown-toc-5-首页文件注册serviceworker">5. 首页文件注册serviceworker</a></li><li><a href="#6-sw-precache-使用总结" id="markdown-toc-6-sw-precache-使用总结">6. Sw-Precache 使用总结</a></li><li><a href="#参考文献" id="markdown-toc-参考文献">参考文献</a></li></ul><p>上一篇文章 <a href="https://vinny.cc/2018/05/pwa-app/">什么是 Progressive Web App 及其使用</a> 中主要说明了基本 PWA 应用的构成及其实现，基本可以达到 PWA 应用的标准。</p><p>本篇将会结合 <a href="https://github.com/GoogleChromeLabs/sw-precache">sw-precache</a> 工具实现自动化的 PWA 应用。</p><h2 id="1-sw-precache-介绍">1. Sw-Precache 介绍</h2><p><strong>sw-precache</strong> 是 Google 提供的 PWA 应用增强的构建工具，可以根据配置自动生成 <em>service-worker.js</em> 文件，构建的过程中根据配置的缓存文件 hash 值更新服务工作线程文件，免去了每次需要修改 <em>service-worker.js</em> 的版本号或者其他信息，以要求浏览器进行缓存的更新。</p><blockquote><p><strong>缓存的更新原则</strong>：若下载的服务工作线程文件与当前的服务器工作线程文件存在字节的差异，则视为新的服务工作线程。</p></blockquote><h2 id="2-sw-precache-安装">2. Sw-Precache 安装</h2><p><strong>sw-precache</strong> 需要结合 <a href="http://gulpjs.com/">Grunt</a> 或者 <a href="http://gruntjs.com/">Gulp</a> 等 javascript 构建工具进行工作，这里使用的是 Gulp。</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install </span>gulp-cli <span class="nt">-g</span> <span class="c"># 安装gulp的cli命令行工具</span>

<span class="nv">$ </span><span class="nb">cd </span>pwa_demo_proj <span class="c"># 进入工程根路径</span>
<span class="nv">$ </span>npm init <span class="c"># 初始化工程</span>
<span class="nv">$ </span>npm <span class="nb">install </span>gulp <span class="nt">--save-dev</span> <span class="c"># 安装gulp依赖</span>
<span class="nv">$ </span>npm <span class="nb">install</span> <span class="nt">--save-dev</span> sw-precache <span class="c"># 安装sw-precache依赖</span>
</code></pre></div></div><h2 id="3-编写gulpfilejs文件">3. 编写gulpfile.js文件</h2><p>在工程根路径创建 <em>gulpfile.js</em> 文件，编写构建任务，明细如下：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s1">'use strict'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">gulp</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'gulp'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'path'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">swPrecache</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'sw-precache'</span><span class="p">);</span>

<span class="nx">gulp</span><span class="p">.</span><span class="nx">task</span><span class="p">(</span><span class="s1">'generate-service-worker'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 定义html文件根路径</span>
    <span class="kd">var</span> <span class="nx">rootDir</span> <span class="o">=</span> <span class="s1">'.'</span><span class="p">;</span>
    
    <span class="c1">// 生成 service-worker.js 文件的 gulp 任务</span>
    <span class="nx">swPrecache</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">rootDir</span><span class="p">,</span> <span class="s1">'service-worker.js'</span><span class="p">),</span> <span class="p">{</span>

        <span class="c1">// ---------------------- 预缓存内容定义 ------------------------</span>
        
        <span class="c1">// 缓存的静态资源，支持模糊匹配</span>
        <span class="na">staticFileGlobs</span><span class="p">:</span> <span class="p">[</span>
			<span class="nx">rootDir</span> <span class="o">+</span> <span class="s1">'/*.html'</span><span class="p">,</span>
			<span class="nx">rootDir</span> <span class="o">+</span> <span class="s1">'/page/*.html'</span><span class="p">,</span>
			<span class="nx">rootDir</span> <span class="o">+</span> <span class="s1">'/assets/js/*.js'</span><span class="p">,</span>
			<span class="nx">rootDir</span> <span class="o">+</span> <span class="s1">'/assets/js/**/*.{js,css}'</span><span class="p">,</span>
			<span class="nx">rootDir</span> <span class="o">+</span> <span class="s1">'/assets/css/*.css'</span><span class="p">,</span>
			<span class="nx">rootDir</span> <span class="o">+</span> <span class="s1">'/assets/img/*.{css,png,jpg,gif}'</span>            
		<span class="p">],</span>
        
        <span class="c1">// 跳过的前缀</span>
        <span class="na">stripPrefix</span><span class="p">:</span> <span class="nx">rootDir</span><span class="p">,</span> 

        <span class="c1">// 在servicerworker中引入js的文件</span>
        <span class="na">importScripts</span><span class="p">:</span> <span class="p">[</span><span class="s1">'config.js'</span><span class="p">,</span> <span class="s1">'sync.js'</span><span class="p">],</span>  

        <span class="c1">// 在资源请求失败时默认的离线页面</span>
        <span class="na">navigateFallback</span><span class="p">:</span> <span class="s1">'offline.html'</span><span class="p">,</span>

        <span class="c1">// ---------------------- 运行时缓存定义 ------------------------</span>
        
        <span class="cm">/*
         * 运行时缓存（runtimeCaching）即在运行时请求的外部资源，对于不常变化的使用缓存有限策略，
         * 反之使用网络优先策略。
         * urlPattern: 支持以正则的形式捕获http请求
         * handler: 处理请求的策略，cacheOnly, networkOnly, cacheFirst, networkFirst,  Fastest
         * options: 可选参数，这里我们给每一类缓存用不同的缓存名称存储，方便查找
         */</span>
        
        <span class="na">runtimeCaching</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="na">urlPattern</span><span class="p">:</span> <span class="sr">/https:</span><span class="se">\/\/</span><span class="sr">jsonplaceholder</span><span class="se">\.</span><span class="sr">typicode</span><span class="se">\.</span><span class="sr">com</span><span class="se">\/</span><span class="sr">users/</span><span class="p">,,</span>
            <span class="na">handler</span><span class="p">:</span> <span class="s1">'cacheOnly'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">cache</span><span class="p">:</span> <span class="p">{</span>
                    <span class="na">name</span><span class="p">:</span> <span class="s1">'users'</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="na">urlPattern</span><span class="p">:</span> <span class="sr">/https:</span><span class="se">\/\/</span><span class="sr">jsonplaceholder</span><span class="se">\.</span><span class="sr">typicode</span><span class="se">\.</span><span class="sr">com</span><span class="se">\/</span><span class="sr">posts/</span><span class="p">,,</span>
            <span class="na">handler</span><span class="p">:</span> <span class="s1">'networkFirst'</span><span class="p">,</span>
            <span class="na">options</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">cache</span><span class="p">:</span> <span class="p">{</span>
                    <span class="na">maxEntries</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                    <span class="na">name</span><span class="p">:</span> <span class="s1">'posts'</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}],</span>
        
        <span class="na">verbose</span><span class="p">:</span> <span class="kc">true</span>  <span class="c1">// 为每个缓存打出日志</span>
    <span class="p">},</span> <span class="nx">callback</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><h2 id="4-生成service-worker文件">4. 生成service-worker文件</h2><p>使用 gulp cli 运行定义在 gulpfile.js 中的 <code class="highlighter-rouge">generate-service-worker</code> 命令，执行完成后，会在路径下生成 <em>service-worker.js</em> 文件，在控制台输出中也会详细输出预缓存的文件列表及缓存大小。</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gulp generate-service-worker
</code></pre></div></div><p>只需要把配置规则定义好，基本上不需要编写 <em>service-worker.js</em> 文件。</p><h2 id="5-首页文件注册serviceworker">5. 首页文件注册serviceworker</h2><p>在脚本文件中对生成的 <em>service-worker.js</em> 文件进行注册</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">if</span> <span class="p">(</span><span class="s1">'serviceWorker'</span> <span class="k">in</span> <span class="nb">navigator</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'load'</span><span class="p">,</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 注册"serviceWorker"</span>
    <span class="nb">navigator</span><span class="p">.</span><span class="nx">serviceWorker</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">'/service-worker.js'</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">registration</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Service Worker registration success with scope: '</span><span class="p">,</span> <span class="nx">registration</span><span class="p">.</span><span class="nx">scope</span><span class="p">);</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Service Worker registration failed: '</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
      <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div><blockquote><p>这里值得注意的是，<strong>sw-precache</strong> 只是用于生成 <em>serviceworker</em>，其他如 <em>manifest.json</em> 文件还是需要自行编写的。</p></blockquote><h2 id="6-sw-precache-使用总结">6. Sw-Precache 使用总结</h2><ol><li>不需要去管 <em>service-worker.js</em> 文件的编写，在 <em>gulpfile.js</em> 文件中定义好 <strong>预缓存</strong> 和 <strong>运行时缓存</strong> 规则，然后就交给 gulp 去做。</li><li>每次在编写完业务代码，在发布到服务器时，都需要执行一次 <code class="highlighter-rouge">gulp generate-service-worker</code> 的命令，让其重新生成服务工作线程文件，更重要的是重新对文件进行哈希。</li></ol><h2 id="参考文献">参考文献</h2><ul><li><a href="https://github.com/GoogleChromeLabs/sw-precache">https://github.com/GoogleChromeLabs/sw-precache</a></li><li><a href="https://codelabs.developers.google.com/codelabs/sw-precache">https://codelabs.developers.google.com/codelabs/sw-precache</a></li><li><a href="https://developers.google.com/web/updates/2015/02/offline-first-with-sw-precache">https://developers.google.com/web/updates/2015/02/offline-first-with-sw-precache</a></li></ul><div class="divider"></div><blockquote id='by-nc-nd'><div> 版权所有，本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">知识共享署名-非商业性使用 3.0 未本地化版本许可协议</a>进行许可。转载请注明出处：<a href="http://www.vinny.cc//2018/05/pwa-sw-precache/" akt="">http://www.vinny.cc//2018/05/pwa-sw-precache/</a></div></blockquote><div class="divider"></div></article><div class="page-navigation"> <a class="next" href="/2018/05/ionic-use/" title="NEXT: 使 ionic 在项目中的最佳实践">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="/" title="Back to Homepage">Home</a> <span> &middot; </span> <a class="prev" href="/2018/05/pwa-app/" title="PREV: 什么是 Progressive Web App 及其使用">&gt;&gt;</a></div><!-- 书签处理 --> <script type="text/javascript" src="/assets/js/zepto.min.js"></script> <script type="text/javascript" src="/assets/js/nav.js"></script></main><!--<div class="footer"> --> <!--</div>--></body></html>